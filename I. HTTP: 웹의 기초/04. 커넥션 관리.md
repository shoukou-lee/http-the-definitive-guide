## TCP 커넥션
### GET http://www.joes-hardware.com:80/power-tools.html 요청의 수행 과정
![tcp-connection](/figures/tcp-connection.png)
1. 브라우저가 hostname `www.joes-hardware.com`를 찾는다.
1. 브라우저가 hostname에 해당하는 IP 주소 `202.43.78.3`을 찾는다.
1. 브라우저가 포트 번호 `80`을 얻는다.
1. 브라우저가 `202.43.78.3:80` 포트로 TCP 커넥션을 생성한다.
1. 브라우저가 서버로 GET 요청을 전송한다.
1. 브라우저가 서버에서 온 응답 메시지를 읽는다.
1. 브라우저가 커넥션을 끊는다.

### HTTP 메시지의 전송
![protocol-stack](/figures/protocol-stack.png)
- HTTP는 TCP 커넥션을 통해 순서대로 메시지를 전송한다.
- TCP는 `Segment` 단위로 데이터를 잘게 나누고, 이는 하나의 IP 패킷이 된다. 이 패킷이 다른 IP로 전달된다.
- TCP의 `per-segment packetization` 과정은 HTTP 프로그래머가 볼 수 없는 영역에서 이루어진다.

### TCP 커넥션의 유지
- TCP 커넥션은 `<발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트>`로 유일하게 식별된다.
- 다시 말하면, 네 요소를 똑같이 가지고 있는 커넥션이 둘 이상 있을 수 없다.

## HTTP 커넥션 관리
### Connection Header
![connection-header](/figures/connection-header.png)

- HTTP 클라이언트와 서버 사이에는 프록시 서버, 캐시 서버 등의 중계 서버가 놓일 수 있다.
- Connection Header는 전송자가 특정 커넥션에만 해당되는 옵션을 지정하게 해줌
- Connection Header을 구성하는
    - `헤더 필드 명`은 이 커넥션에만 해당되는 헤더들을 나열하며, 이 헤더들은 다음 서버에는 전달되지 않음
    - `임시 토큰 값`은 커넥션에 대한 비표준 옵션을 의미
    - `close`는 작업 완료 시 커넥션이 종료되어야 함을 의미
- 위 그림에서, meter 헤더는 다음 서버로 전달되지 않고, 'bill-my-credit-card' 옵션을 적용하며, 이 트랜잭션 후 커넥션이 끊김을 의미

### 순차적인 트랜잭션 처리에 의한 지연
- 예를 들어, 이미지 3개가 있는 웹 페이지 화면을 표현하려면 총 4번(HTML, 3개의 이미지 요청)의 트랜잭션이 필요
- 이러한 과정을 순차적으로 처리하면 긴 지연 발생, 게다가 매 트랜잭션마다 새 TCP 커넥션을 시도한다면 성능 악화
- 이를 해결하기 위해
    - 병렬 커넥션 (여러 TCP 커넥션으로 동시 HTTP 요청)
    - 지속 커넥션 (TCP 커넥션의 재활용)
    - 파이프라인 커넥션 (공유 TCP 커넥션으로 파이프라이닝)
    - 다중 커넥션

## 병렬 커넥션
![parallel-connection](/figures/parallel-connection.png)
![parallel-transaction](/figures/parallel-transaction.png)

### 병렬 커넥션은 일반적으로 빠르다
- 순차적인 TCP 커넥션으로 인한 지연이 병렬화
- 또한 리소스 다운로드도 별도의 커넥션에서 병렬처리됨으로 총 지연 감소
- 그림은 Connection 2-4가 병렬로 처리되고 있음을 보여줌 (각 커넥션 간 텀은 S/W적 이유로 작은 term이 존재함을 의미)

### 항상 빠르지는 않다
- 클라이언트의 대역폭이 고갈된 경우, 병렬 리소스 다운로드의 의미가 없어짐
- 다수의 커넥션은 곧 더 많은 자원 소모를 의미 (메모리 등)
- 서버 부하로 인한 성능 저하 : 한 페이지에 10개의 커넥션이 맺어진 경우, 클라이언트가 100명이 동시접속한다면?
- 단, 병렬 커넥션이 수치적으로 빠르지 않더라도, 사용자 입장에서는 여러 리소스가 동시에 보여지는 것이 더 빠르다고 느낄 수 있음 (e.g., 한도 대역폭 내에서 Progressive-JPEG로 일단 여러 이미지를 표현하는 경우)

## 지속 커넥션
- `site locality` : 한 서버에 요청을 한 앱은, 해당 페이지의 다른 리소스를 가져오기 위해 또 요청을 시도할 것
- HTTP/1.1 이상부터는 트랜잭션을 완료한 후에도 TCP 커넥션을 유지, 다음 요청에 재사용
- 새로운 TCP 커넥션을 시도하는 것이 아니므로, 커넥션 지연을 줄임
- 지속 커넥션을 잘못 관리하게 되면 연결된 상태로 남은 커넥션들이 쌓일 수 있음

### keep-alive 커넥션
![keep-alive](/figures/keep-alive.png)
- HTTP/1.0+에서 지원하는 지속 커넥션의 한 종류
- HTTP/1.1 명세에서는 제외되었으나, 아직 많은 서버/클라이언트가 keep-alive 커넥션을 사용
- 그림은 하나의 keep-alive 커넥션이 4개의 트랜잭션을 처리하는 것을 보여줌
